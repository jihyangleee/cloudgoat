# Scenario: s3_version_rollback_via_cfn

**Size:** Small

**Difficulty:** Hard

**Command:** `$ ./cloudgoat.py create s3_version_rollback_via_cfn`

### ðŸ§¹ Clean up versioned S3 buckets before CG destroy: 
Make sure to run this script before CG destroy, run:
```
bash ./cleanup_s3.sh
```
ðŸ’¡ This script must be executed from the same directory where start.txt is located, as it automatically reads Terraform outputs (such as cgid and profile) from that file generated by cloudgoat create.
And handles Governance Locked buckets using --bypass-governance-retention when necessary.

## Scenario Resources

* 1 IAM User
* S3 x 1

## Scenario Start(s)

1 IAM User, 1 Public S3 website endpoint URL

## Scenario Goal(s)

Recover the previous version of `index.html` in the S3 static website and expose the hidden FLAG.

## Summary

Start with an S3 static website and a Web Manager IAM User. The attacker checks permissions to identify vulnerabilities in S3 versioning and object locking, and bypasses them to escalate privileges. Analyze permissions to restore previous versions of the page and get the "FLAG".

## Exploitation Route(s)

![Scenario Route(s)](./assets/route.png)

## Walkthrough - s3_version_rollback_via_cfn

1. The attacker accesses a publicly exposed static website hosted on S3. At first glance, it appears to be a simple landing page, but by analyzing the URL structure, they deduce that it's using S3 static website hosting.

2. By exploring the permissions associated with their IAM credentials, the attacker discovers that they have access to list objects and object versions within the S3 bucket.

3. The attacker finds that the `index.html` object exists in two versions, and the older version contains sensitive information.

4. The attacker has obtained the previous version of the file, but is unable to download the important flag file. Attacker realizes that he must restore it directly to the web page. But `PutObject` permission was Deny.

5. Analysis of the user's inline IAM policy shows that the attacker is allowed 'Cloud Formation: CreateStack' and 'Lambda: InvokeFunction'. It also checks the Role of resources with passrole privileges.

6. Check the roles and the policies attached to them to create a cloud information stack by creating a lambda function as a template that uploads objects to their buckets.

7. Invoke the functions created in the stack using IAM permissions.

8. The Lambda function created by the template allows an attacker to re-upload the previously obtained 'index.html', effectively overwriting the current version to the previous version.

9. When you revisit the static website URL, the modified index page is activated, flagged, and the scenario is complete.

10. This led us to realize that the combination of object locking and version management was a pointless security setting, and we successfully leveraged the misconfigured IAM Role and CloudFormation to expand our authority.

A cheat sheet for this route is available [here](./cheat_sheet.md).
